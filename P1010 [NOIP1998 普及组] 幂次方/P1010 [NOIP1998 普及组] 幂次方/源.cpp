#define _CRT_SECURE_NO_WARNINGS 1
#include <stdio.h>
#include<string.h>

void dig(int n) {      //首先，我们明确，每次就给求的数建立格式，如1315 最后可表示为 2(2(2+2(0))+2)+2(2(2+2(0)))+2(2(2)+2(0))+2+2(0)2(2(2+2(0))+2)+2(2(2+2(0)))+2(2(2)+2(0))+2+2(0)。
	              //那么1315我们就可以先看出5个部分组成，然后为每个部分建立格式模板，如第一个是2的10次方大于2，那么为他放一个2（dig(i))的模板，i表示其次方，如这里i为10，则进入递归按模板填完10就出来
		int flag = 1;//用flag判断是不是第一次进入循环
		for (int i = 14; i >= 0; --i) {
			if ((n >> i) & 1)  //因为数据n小于2×10^4,那么小于2的14次方，我们从高到低，比较n的二进制位，如果是1，那么表达式(n >> i) & 1返回1，进入内部
			{
				if (!flag)printf("+");   //每一个递归的第一个部分，如2的10次方为第一部分或者2的3次方是10的第一部分，那么前面就不需要+，其余都要
				if (flag)flag = 0;  //只要第一次过后，后面都要+，所以flag在此递归后面全为0
					
				if (i == 0)printf("2(0)");   //i为0和1次方需要特判，因为他们不需要2（...）的模板
					else if (i == 1)printf("2");
					else {
						printf("2(");
						dig(i);
						printf(")");
					}
				
			}

		}
	
}
	int main() {
		int n;
		scanf("%d", &n);
		dig(n);

		return 0;
	}


	/*任何一个正整数都可以用 22 的幂次方表示。例如 137 = 2 ^ 7 + 2 ^ 3 + 2 ^ 0137 = 2
		7
		+ 2
		3
		+ 2
		0
		。

		同时约定方次用括号来表示，即 a ^ ba
		b
		可表示为 a(b)a(b)。

		由此可知，137137 可表示为 2(7) + 2(3) + 2(0)2(7) + 2(3) + 2(0)

		进一步：

		7 = 2 ^ 2 + 2 + 2 ^ 07 = 2
		2
		+ 2 + 2
		0
		(2 ^ 12
			1
			用 22 表示)，并且 3 = 2 + 2 ^ 03 = 2 + 2
		0
		。

		所以最后 137137 可表示为 2(2(2) + 2 + 2(0)) + 2(2 + 2(0)) + 2(0)2(2(2) + 2 + 2(0)) + 2(2 + 2(0)) + 2(0)。

		又如 1315 = 2 ^ {10} + 2 ^ 8 + 2 ^ 5 + 2 + 11315 = 2
		10
		+ 2
		8
		+ 2
		5
		+ 2 + 1

		所以 13151315 最后可表示为 2(2(2 + 2(0)) + 2) + 2(2(2 + 2(0))) + 2(2(2) + 2(0)) + 2 + 2(0)2(2(2 + 2(0)) + 2) + 2(2(2 + 2(0))) + 2(2(2) + 2(0)) + 2 + 2(0)*/