#define _CRT_SECURE_NO_WARNINGS 1
#include <stdio.h>
#include<string.h>
#include<algorithm>
#include<iostream>
using namespace std;
          //进制转换的关键是余数
void myturn(int x, int y) {
	if (x == 0)return;//x为0（被除数为0就不用继续了）
	int m = x % y;//因为转换为进制都是整数，必须保证m为正数
	if (m < 0) { m -= y; x += y; }//因为除数为负数，我们只需要将商+1，余数-除数即可，因为余数（绝对值）一定小于除数，所以这样就可以将余数装换为正数
	myturn(x / y, y);//（商+1）*除数+（余数-除数）=商*除数+除数+余数-除数=商*除数+余数=被除数，所以余数减一个除数，然后被减数加一个除数，就等价于商加一
	if (m > 9)m = 'A' + m - 10;
	else m = '0' + m;
	printf("%c", m);  //因为进制转换，所以全部都以阿斯玛值打印比较容易
}  //注意，因为结果为余数倒序，输出要写在递归后面，不然会顺序输出，所以最开始的最后打印

int arr[1000];
int main() {
	int n, r,sum=1;
	cin >> n >> r;
	cout << n << "=";
	myturn(n, r);
	cout << "(base" << r << ")";
	return 0;
}



//
//我们可以用这样的方式来表示一个十进制数: 将每个阿拉伯数字乘以一个以该数字所处位置为指数, 以 1010 为底数的幂之和的形式。例如 123123 可表示为 1 \times 10 ^ 2 + 2\times 10 ^ 1 + 3\times 10 ^ 01×10
//2
//+ 2×10
//1
//+ 3×10
//0
//这样的形式。
//
//与之相似的，对二进制数来说，也可表示成每个二进制数码乘以一个以该数字所处位置为指数, 以 22 为底数的幂之和的形式。
//
//一般说来，任何一个正整数 RR 或一个负整数 - R−R 都可以被选来作为一个数制系统的基数。如果是以 RR 或 - R−R 为基数, 则需要用到的数码为 0, 1, ....R - 10, 1, ....R−1。
//
//例如当 R = 7R = 7 时, 所需用到的数码是 0, 1, 2, 3, 4, 5, 60, 1, 2, 3, 4, 5, 6，这与其是 RR 或 - R−R 无关。如果作为基数的数绝对值超过 1010, 则为了表示这些数码，通常使用英文字母来表示那些大于 99 的数码。例如对 1616 进制数来说, 用 AA 表示 1010, 用 BB 表示 1111，用 CC 表示 1212，以此类推。
//
//在负进制数中是用 - R−R 作为基数，例如 - 15−15（十进制）相当于 110001110001 （ - 2−2进制），并且它可以被表示为 22 的幂级数的和数：
//
//110001 = 1\times(-2) ^ 5 + 1\times(-2) ^ 4 + 0\times(-2) ^ 3 + 0\times(-2) ^ 2 + 0\times(-2) ^ 1 + 1\times(-2) ^ 0
//110001 = 1×(−2)
//5
//+ 1×(−2)
//4
//+ 0×(−2)
//3
//+ 0×(−2)
//2
//+ 0×(−2)
//1
//+ 1×(−2)
//0
//
//
//设计一个程序, 读入一个十进制数和一个负进制数的基数, 并将此十进制数转换为此负进制下的数。
//
//输入格式
//输入的每行有两个输入数据。
//
//第一个是十进制数 nn。 第二个是负进制数的基数 - R−R。
//
//输出格式
//输出此负进制数及其基数，若此基数超过 1010，则参照 1616 进制的方式处理。





